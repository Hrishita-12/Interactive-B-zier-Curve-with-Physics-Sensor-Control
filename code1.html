<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Interactive Bézier Curve with Physics & Sensors</title>
<style>
  html,body { height:100%; margin:0; background:#5f5c5c; color:#bbb1b1; font-family: sans-serif; }
  canvas { display:block; width:100vw; height:100vh; }
  .hint { position:fixed; left:12px; top:12px; background: rgba(0,0,0,0.7); padding:8px 10px; border-radius:8px; font-size:12px; z-index:10; }
  .controls { position:fixed; right:12px; top:12px; background: rgba(0,0,0,0.7); padding:10px; border-radius:8px; display:flex; flex-direction:column; gap:8px; z-index:10; }
  .control-group { display:flex; gap:8px; align-items:center; }
  .control-group label { font-size:11px; min-width: 80px; }
  .control-group input[type="range"] { width: 100px; }
  .value { font-size:11px; min-width: 30px; text-align:right; }
  button { padding:4px 8px; font-size:11px; cursor:pointer; background:#333; color:white; border:none; border-radius:4px; }
  button:hover { background:#444; }
  .status { position:fixed; left:12px; bottom:12px; background: rgba(15, 15, 15, 0.7); padding:8px 10px; border-radius:8px; font-size:11px; z-index:10; }
  
  /* Physics Monitor */
  .physics-monitor {
    position: fixed;
    left: 12px;
    top: 60px;
    background: rgba(0, 0, 0, 0.85);
    padding: 15px;
    border-radius: 8px;
    font-family: 'Courier New', monospace;
    font-size: 12px;
    min-width: 300px;
    border-left: 4px solid #4cc9f0;
    z-index: 10;
  }
  
  .physics-monitor h3 {
    margin: 0 0 10px 0;
    color: #4cc9f0;
    font-size: 14px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .point-toggle {
    display: flex;
    gap: 5px;
  }
  
  .point-toggle button {
    padding: 2px 6px;
    font-size: 10px;
    background: #444;
  }
  
  .point-toggle button.active {
    background: #4cc9f0;
    font-weight: bold;
  }
  
  .physics-data {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }
  
  .point-header {
    grid-column: 1 / -1;
    font-weight: bold;
    margin-top: 5px;
    padding-bottom: 3px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }
  
  .physics-item {
    display: flex;
    justify-content: space-between;
  }
  
  .physics-label {
    color: #aaa;
  }
  
  .physics-value {
    color: #fff;
    text-align: right;
    min-width: 80px;
  }
  
  .formula-display {
    margin-top: 15px;
    padding: 10px;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 5px;
    border-left: 3px solid #f72585;
  }
  
  .formula-display .eq {
    color: #4cc9f0;
    font-size: 11px;
  }
  
  .formula-display .var {
    color: #fbbf24;
  }
  
  .formula-display .const {
    color: #10b981;
  }
  
  /* Color coding */
  .spring-force { color: #4cc9f0; }
  .damping-force { color: #f72585; }
  .net-force { color: #fbbf24; }
  .velocity { color: #10b981; }
  .acceleration { color: #e879f9; }
  
  /* Point indicator in header */
  .point-indicator {
    color: #fbbf24;
    font-weight: bold;
  }
</style>
</head>
<body>
<div class="hint">Drag P₁ or P₂ (yellow). P₀ & P₃ are fixed. Press R to reset.</div>
<div class="controls">
  <div class="control-group">
    <label>Stiffness:</label>
    <input type="range" id="stiffness" min="0.01" max="0.2" step="0.01" value="0.08">
    <div class="value" id="stiffnessValue">0.08</div>
  </div>
  <div class="control-group">
    <label>Damping:</label>
    <input type="range" id="damping" min="0.05" max="0.2" step="0.01" value="0.12">
    <div class="value" id="dampingValue">0.12</div>
  </div>
  <div class="control-group">
    <label>Tangents:</label>
    <input type="range" id="tangents" min="5" max="30" step="1" value="15">
    <div class="value" id="tangentsValue">15</div>
  </div>
  <button id="enableMotion">Enable Motion</button>
</div>

<!-- Physics Monitor -->
<div class="physics-monitor">
  <h3>
    <span>Physics Monitor: <span class="point-indicator" id="pointIndicator">P₁</span></span>
    <div class="point-toggle">
      <button id="toggleP1" class="active">P₁</button>
      <button id="toggleP2">P₂</button>
    </div>
  </h3>
  <div class="physics-data">
    <div class="point-header">Current Values</div>
    
    <div class="physics-item">
      <span class="physics-label">Position (x,y):</span>
      <span class="physics-value" id="posValue">0, 0</span>
    </div>
    
    <div class="physics-item">
      <span class="physics-label">Target (x,y):</span>
      <span class="physics-value" id="targetValue">0, 0</span>
    </div>
    
    <div class="physics-item">
      <span class="physics-label velocity">Velocity (x,y):</span>
      <span class="physics-value" id="velValue">0, 0</span>
    </div>
    
    <div class="physics-item">
      <span class="physics-label acceleration">Acceleration (x,y):</span>
      <span class="physics-value" id="accValue">0, 0</span>
    </div>
    
    <div class="point-header">Forces</div>
    
    <div class="physics-item">
      <span class="physics-label spring-force">Spring Force (Fₛ):</span>
      <span class="physics-value" id="springForceValue">0, 0</span>
    </div>
    
    <div class="physics-item">
      <span class="physics-label damping-force">Damping Force (Fₔ):</span>
      <span class="physics-value" id="dampingForceValue">0, 0</span>
    </div>
    
    <div class="physics-item">
      <span class="physics-label net-force">Net Force (Fₙ):</span>
      <span class="physics-value" id="netForceValue">0, 0</span>
    </div>
    
    <div class="physics-item">
      <span class="physics-label">Mass (m):</span>
      <span class="physics-value">1.0 kg</span>
    </div>
    
    <div class="point-header">Comparison</div>
    
    <div class="physics-item">
      <span class="physics-label">Distance to Target:</span>
      <span class="physics-value" id="distanceValue">0.0</span>
    </div>
    
    <div class="physics-item">
      <span class="physics-label">Speed:</span>
      <span class="physics-value" id="speedValue">0.0</span>
    </div>
    
    <div class="physics-item">
      <span class="physics-label">Force Magnitude:</span>
      <span class="physics-value" id="forceMagValue">0.0</span>
    </div>
    
    <div class="physics-item">
      <span class="physics-label">Accel Magnitude:</span>
      <span class="physics-value" id="accelMagValue">0.0</span>
    </div>
  </div>
  
  <div class="formula-display">
    <div class="eq">Physics Equation: <span class="var">a</span> = [<span class="const">-K</span>·(<span class="var">x</span>-<span class="var">x₀</span>) - <span class="const">D</span>·<span class="var">v</span>] / <span class="var">m</span></div>
    <div style="margin-top: 5px; font-size: 10px; color: #aaa;">
      K = <span id="currentK">0.08</span> | D = <span id="currentD">0.12</span> | m = 1.0
    </div>
  </div>
</div>

<div class="status" id="status">FPS: 60 | Mode: Mouse</div>
<canvas id="c"></canvas>
<script>
(() => {
  // Canvas setup
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  
  function resize() {
    canvas.width = innerWidth * devicePixelRatio;
    canvas.height = innerHeight * devicePixelRatio;
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  // 1. MANUAL BÉZIER MATH
  function cubicBezierPoint(t, p0, p1, p2, p3) {
    const u = 1 - t;
    const u2 = u * u;
    const u3 = u2 * u;
    const t2 = t * t;
    const t3 = t2 * t;
    
    const x = u3 * p0.x + 3 * u2 * t * p1.x + 3 * u * t2 * p2.x + t3 * p3.x;
    const y = u3 * p0.y + 3 * u2 * t * p1.y + 3 * u * t2 * p2.y + t3 * p3.y;
    
    return {x, y};
  }

  // 2. TANGENT CALCULATION
  function cubicBezierTangent(t, p0, p1, p2, p3) {
    const u = 1 - t;
    const u2 = u * u;
    const t2 = t * t;
    
    const dx = 3 * u2 * (p1.x - p0.x) + 6 * u * t * (p2.x - p1.x) + 3 * t2 * (p3.x - p2.x);
    const dy = 3 * u2 * (p1.y - p0.y) + 6 * u * t * (p2.y - p1.y) + 3 * t2 * (p3.y - p2.y);
    
    const length = Math.sqrt(dx * dx + dy * dy);
    if (length === 0) return {x: 0, y: 0};
    return {x: dx / length, y: dy / length};
  }

  // Physics parameters
  let K = 0.08;        // spring stiffness
  let DAMP = 0.12;     // damping coefficient
  const SENSOR_SCALE = 0.7;
  const dt = 1/60;
  let tangentLength = 15;

  // Track which point we're monitoring
  let monitorPointIndex = 1; // Start with P₁ (index 1)

  // Physics data storage
  let physicsData = {
    point1: {
      springForce: {x: 0, y: 0},
      dampingForce: {x: 0, y: 0},
      netForce: {x: 0, y: 0},
      acceleration: {x: 0, y: 0},
      lastUpdate: 0
    },
    point2: {
      springForce: {x: 0, y: 0},
      dampingForce: {x: 0, y: 0},
      netForce: {x: 0, y: 0},
      acceleration: {x: 0, y: 0},
      lastUpdate: 0
    }
  };

  // Control points structure
  const points = [];
  
  function makePoint(x, y, isFixed = false) {
    return {
      p: {x, y},
      v: {x: 0, y: 0},
      rest: {x, y},
      mass: 1,
      radius: 8,
      isFixed: isFixed,
      color: isFixed ? '#10b981' : '#fbbf24'
    };
  }
  
  function init() {
    points.length = 0;
    const w = innerWidth, h = innerHeight;
    
    points.push(makePoint(w * 0.1, h * 0.5, true));   // P₀ - fixed
    points.push(makePoint(w * 0.3, h * 0.3, false));  // P₁ - dynamic
    points.push(makePoint(w * 0.7, h * 0.7, false));  // P₂ - dynamic
    points.push(makePoint(w * 0.9, h * 0.5, true));   // P₃ - fixed
  }
  
  init();

  // FPS counter
  let fps = 60;
  let frameCount = 0;
  let lastFpsTime = performance.now();
  
  // Pointer interaction
  let dragging = null;
  let pointer = {x: 0, y: 0, down: false};
  
  function getEventPos(e) {
    if (e.touches && e.touches.length) {
      return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }
    return { x: e.clientX, y: e.clientY };
  }

  function findNearbyPoint(x, y, maxDist = 24) {
    for (let i = 1; i <= 2; i++) {
      const dx = points[i].p.x - x, dy = points[i].p.y - y;
      if (Math.hypot(dx, dy) <= maxDist) return i;
    }
    return null;
  }

  canvas.addEventListener('pointerdown', e => {
    const pos = getEventPos(e);
    const idx = findNearbyPoint(pos.x, pos.y);
    if (idx !== null) {
      dragging = idx;
      pointer.down = true;
      pointer.x = pos.x; pointer.y = pos.y;
      points[dragging].rest.x = pointer.x;
      points[dragging].rest.y = pointer.y;
    }
  });
  
  window.addEventListener('pointermove', e => {
    const pos = getEventPos(e);
    pointer.x = pos.x; pointer.y = pos.y;
    if (dragging !== null) {
      points[dragging].rest.x = pointer.x;
      points[dragging].rest.y = pointer.y;
      points[dragging].p.x = pointer.x;
      points[dragging].p.y = pointer.y;
      points[dragging].v.x = points[dragging].v.y = 0;
    }
  });
  
  window.addEventListener('pointerup', e => {
    dragging = null;
    pointer.down = false;
  });

  // Keyboard
  window.addEventListener('keydown', e => {
    if (e.key === 'r' || e.key === 'R') {
      init();
    }
  });

  // Device orientation
  let sensorForce = {x: 0, y: 0};
  let motionEnabled = false;
  
  function handleDeviceOrientation(e) {
    if (!motionEnabled) return;
    
    const gx = e.gamma || 0;
    const gy = e.beta || 0;
    
    sensorForce.x = gx * 0.03 * SENSOR_SCALE;
    sensorForce.y = gy * 0.03 * SENSOR_SCALE;
  }
  
  document.getElementById('enableMotion').addEventListener('click', async () => {
    if (typeof DeviceOrientationEvent !== 'undefined' &&
        typeof DeviceOrientationEvent.requestPermission === 'function') {
      try {
        const perm = await DeviceOrientationEvent.requestPermission();
        if (perm === 'granted') {
          motionEnabled = true;
          window.addEventListener('deviceorientation', handleDeviceOrientation);
          document.getElementById('status').textContent = 'FPS: 60 | Mode: Motion';
        }
      } catch(err) {
        console.warn('Motion permission error:', err);
      }
    } else {
      motionEnabled = true;
      window.addEventListener('deviceorientation', handleDeviceOrientation);
      document.getElementById('status').textContent = 'FPS: 60 | Mode: Motion';
    }
  });

  // Physics update with data collection
  function stepPhysics(dt) {
    for (let i = 0; i < points.length; i++) {
      const pt = points[i];
      
      if (pt.isFixed) continue;
      
      // Spring force: Fₛ = -K * (x - x₀)
      const springX = -K * (pt.p.x - pt.rest.x);
      const springY = -K * (pt.p.y - pt.rest.y);
      
      // Damping force: Fₔ = -D * v
      const dampX = -DAMP * pt.v.x;
      const dampY = -DAMP * pt.v.y;
      
      // Sensor/mouse force
      let sensorX = 0, sensorY = 0;
      if (motionEnabled) {
        sensorX = sensorForce.x * 50;
        sensorY = sensorForce.y * 50;
      } else {
        if (!pointer.down && dragging !== i) {
          const dx = pointer.x - pt.p.x;
          const dy = pointer.y - pt.p.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 150) {
            const strength = 1 - (dist / 150);
            sensorX = dx * strength * 0.1;
            sensorY = dy * strength * 0.1;
          }
        }
      }
      
      // Net force: Fₙ = Fₛ + Fₔ + Fₛₑₙₛₒᵣ
      const netX = springX + dampX + sensorX;
      const netY = springY + dampY + sensorY;
      
      // Acceleration: a = Fₙ / m
      const ax = netX / pt.mass;
      const ay = netY / pt.mass;
      
      // Store physics data for P₁ and P₂
      if (i === 1) {
        physicsData.point1.springForce = {x: springX, y: springY};
        physicsData.point1.dampingForce = {x: dampX, y: dampY};
        physicsData.point1.netForce = {x: netX, y: netY};
        physicsData.point1.acceleration = {x: ax, y: ay};
        physicsData.point1.lastUpdate = performance.now();
      } else if (i === 2) {
        physicsData.point2.springForce = {x: springX, y: springY};
        physicsData.point2.dampingForce = {x: dampX, y: dampY};
        physicsData.point2.netForce = {x: netX, y: netY};
        physicsData.point2.acceleration = {x: ax, y: ay};
        physicsData.point2.lastUpdate = performance.now();
      }
      
      // Integrate velocity
      pt.v.x += ax * dt;
      pt.v.y += ay * dt;
      
      // Integrate position
      pt.p.x += pt.v.x * dt * 60;
      pt.p.y += pt.v.y * dt * 60;
      
      // Boundary constraints
      const margin = 20;
      if (pt.p.x < margin) { pt.p.x = margin; pt.v.x *= -0.5; }
      if (pt.p.x > innerWidth - margin) { pt.p.x = innerWidth - margin; pt.v.x *= -0.5; }
      if (pt.p.y < margin) { pt.p.y = margin; pt.v.y *= -0.5; }
      if (pt.p.y > innerHeight - margin) { pt.p.y = innerHeight - margin; pt.v.y *= -0.5; }
    }
  }

  // NEW: Update physics monitor display for selected point
  function updatePhysicsMonitor() {
    const pointIndex = monitorPointIndex; // 1 for P₁, 2 for P₂
    const pt = points[pointIndex];
    const pData = pointIndex === 1 ? physicsData.point1 : physicsData.point2;
    
    // Update point indicator
    document.getElementById('pointIndicator').textContent = `P${pointIndex}`;
    document.getElementById('toggleP1').classList.toggle('active', pointIndex === 1);
    document.getElementById('toggleP2').classList.toggle('active', pointIndex === 2);
    
    // Position and target
    document.getElementById('posValue').textContent = 
      `${pt.p.x.toFixed(1)}, ${pt.p.y.toFixed(1)}`;
    document.getElementById('targetValue').textContent = 
      `${pt.rest.x.toFixed(1)}, ${pt.rest.y.toFixed(1)}`;
    
    // Velocity (scaled for readability)
    document.getElementById('velValue').textContent = 
      `${(pt.v.x * 10).toFixed(2)}, ${(pt.v.y * 10).toFixed(2)}`;
    
    // Acceleration
    document.getElementById('accValue').textContent = 
      `${pData.acceleration.x.toFixed(3)}, ${pData.acceleration.y.toFixed(3)}`;
    
    // Forces
    document.getElementById('springForceValue').textContent = 
      `${pData.springForce.x.toFixed(3)}, ${pData.springForce.y.toFixed(3)}`;
    
    document.getElementById('dampingForceValue').textContent = 
      `${pData.dampingForce.x.toFixed(3)}, ${pData.dampingForce.y.toFixed(3)}`;
    
    document.getElementById('netForceValue').textContent = 
      `${pData.netForce.x.toFixed(3)}, ${pData.netForce.y.toFixed(3)}`;
    
    // Calculate magnitudes for comparison
    const distance = Math.sqrt(
      Math.pow(pt.p.x - pt.rest.x, 2) + 
      Math.pow(pt.p.y - pt.rest.y, 2)
    );
    
    const speed = Math.sqrt(pt.v.x * pt.v.x + pt.v.y * pt.v.y) * 10;
    const forceMag = Math.sqrt(
      pData.netForce.x * pData.netForce.x + 
      pData.netForce.y * pData.netForce.y
    );
    const accelMag = Math.sqrt(
      pData.acceleration.x * pData.acceleration.x + 
      pData.acceleration.y * pData.acceleration.y
    );
    
    document.getElementById('distanceValue').textContent = distance.toFixed(2);
    document.getElementById('speedValue').textContent = speed.toFixed(2);
    document.getElementById('forceMagValue').textContent = forceMag.toFixed(3);
    document.getElementById('accelMagValue').textContent = accelMag.toFixed(3);
    
    // Current physics constants
    document.getElementById('currentK').textContent = K.toFixed(2);
    document.getElementById('currentD').textContent = DAMP.toFixed(2);
  }

  // NEW: Point toggle buttons
  document.getElementById('toggleP1').addEventListener('click', () => {
    monitorPointIndex = 1;
    updatePhysicsMonitor();
  });
  
  document.getElementById('toggleP2').addEventListener('click', () => {
    monitorPointIndex = 2;
    updatePhysicsMonitor();
  });

  // Drawing function
  function draw() {
    // Clear canvas
    const gradient = ctx.createLinearGradient(0, 0, innerWidth, innerHeight);
    gradient.addColorStop(0, '#16151a');
    gradient.addColorStop(1, '#16151a');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, innerWidth, innerHeight);
    
    // Draw grid
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
    ctx.lineWidth = 1;
    const gridSize = 50;
    for (let x = 0; x < innerWidth; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, innerHeight);
      ctx.stroke();
    }
    for (let y = 0; y < innerHeight; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(innerWidth, y);
      ctx.stroke();
    }
    
    // Draw Bézier curve
    ctx.beginPath();
    const segments = 200;
    for (let i = 0; i <= segments; i++) {
      const t = i / segments;
      const point = cubicBezierPoint(t, points[0].p, points[1].p, points[2].p, points[3].p);
      
      if (i === 0) {
        ctx.moveTo(point.x, point.y);
      } else {
        ctx.lineTo(point.x, point.y);
      }
    }
    
    ctx.strokeStyle = '#30d0f0';
    ctx.lineWidth = 8;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.stroke();
    
    // Draw tangents
    const tangentCount = 20;
    for (let i = 0; i <= tangentCount; i++) {
      const t = i / tangentCount;
      const point = cubicBezierPoint(t, points[0].p, points[1].p, points[2].p, points[3].p);
      const tangent = cubicBezierTangent(t, points[0].p, points[1].p, points[2].p, points[3].p);
      
      ctx.beginPath();
      ctx.moveTo(point.x, point.y);
      ctx.lineTo(
        point.x + tangent.x * tangentLength,
        point.y + tangent.y * tangentLength
      );
      ctx.strokeStyle = '#cc2512';
      ctx.lineWidth = 4;
      ctx.stroke();
      
      ctx.beginPath();
      ctx.arc(
        point.x + tangent.x * tangentLength,
        point.y + tangent.y * tangentLength,
        3, 0, Math.PI * 2
      );
      ctx.fillStyle = '#f72585';
      ctx.fill();
    }
    
    // Draw control lines
    ctx.beginPath();
    ctx.moveTo(points[0].p.x, points[0].p.y);
    ctx.lineTo(points[1].p.x, points[1].p.y);
    ctx.lineTo(points[2].p.x, points[2].p.y);
    ctx.lineTo(points[3].p.x, points[3].p.y);
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 3]);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Draw control points
    for (let i = 0; i < points.length; i++) {
      const pt = points[i];
      
      // Highlight the monitored point with a larger outline
      if (i === monitorPointIndex) {
        ctx.beginPath();
        ctx.arc(pt.p.x, pt.p.y, 18, 0, Math.PI * 2);
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      
      if (i === 1 || i === 2) {
        ctx.beginPath();
        ctx.arc(pt.p.x, pt.p.y, 15, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
      
      ctx.beginPath();
      ctx.arc(pt.p.x, pt.p.y, pt.radius, 0, Math.PI * 2);
      ctx.fillStyle = pt.color;
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(pt.p.x, pt.p.y, pt.radius, 0, Math.PI * 2);
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      ctx.fillStyle = 'white';
      ctx.font = 'bold 16px Arial';
      ctx.fillText(`P${i}`, pt.p.x - 10, pt.p.y - 15);
    }
    
    // Draw Bézier sample points
    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
    for (let t = 0; t <= 1; t += 0.02) {
      const point = cubicBezierPoint(t, points[0].p, points[1].p, points[2].p, points[3].p);
      ctx.fillRect(point.x - 1.5, point.y - 1.5, 3, 3);
    }
    
    // Visualize forces on monitored point
    const monitoredPt = points[monitorPointIndex];
    const monitoredData = monitorPointIndex === 1 ? physicsData.point1 : physicsData.point2;
    
    // Draw spring force vector (blue)
    ctx.beginPath();
    ctx.moveTo(monitoredPt.p.x, monitoredPt.p.y);
    ctx.lineTo(
      monitoredPt.p.x + monitoredData.springForce.x * 2, 
      monitoredPt.p.y + monitoredData.springForce.y * 2
    );
    ctx.strokeStyle = '#4cc9f0';
    ctx.lineWidth = 3;
    ctx.stroke();
    
    // Draw damping force vector (red)
    ctx.beginPath();
    ctx.moveTo(monitoredPt.p.x, monitoredPt.p.y);
    ctx.lineTo(
      monitoredPt.p.x + monitoredData.dampingForce.x * 2, 
      monitoredPt.p.y + monitoredData.dampingForce.y * 2
    );
    ctx.strokeStyle = '#f72585';
    ctx.lineWidth = 3;
    ctx.stroke();
    
    // Draw net force vector (yellow)
    ctx.beginPath();
    ctx.moveTo(monitoredPt.p.x, monitoredPt.p.y);
    ctx.lineTo(
      monitoredPt.p.x + monitoredData.netForce.x * 2, 
      monitoredPt.p.y + monitoredData.netForce.y * 2
    );
    ctx.strokeStyle = '#fbbf24';
    ctx.lineWidth = 4;
    ctx.stroke();
    
    // Draw labels for forces
    ctx.fillStyle = '#4cc9f0';
    ctx.font = 'bold 12px Arial';
    ctx.fillText(
      'Fₛ', 
      monitoredPt.p.x + monitoredData.springForce.x * 2 + 5, 
      monitoredPt.p.y + monitoredData.springForce.y * 2
    );
    
    ctx.fillStyle = '#f72585';
    ctx.fillText(
      'Fₔ', 
      monitoredPt.p.x + monitoredData.dampingForce.x * 2 + 5, 
      monitoredPt.p.y + monitoredData.dampingForce.y * 2
    );
    
    ctx.fillStyle = '#fbbf24';
    ctx.fillText(
      'Fₙ', 
      monitoredPt.p.x + monitoredData.netForce.x * 2 + 5, 
      monitoredPt.p.y + monitoredData.netForce.y * 2
    );
    
    // Update FPS counter
    frameCount++;
    const now = performance.now();
    if (now - lastFpsTime >= 1000) {
      fps = Math.round((frameCount * 1000) / (now - lastFpsTime));
      frameCount = 0;
      lastFpsTime = now;
      
      const mode = motionEnabled ? 'Motion' : 'Mouse';
      document.getElementById('status').textContent = `FPS: ${fps} | Mode: ${mode}`;
    }
    
    // Update physics monitor
    updatePhysicsMonitor();
  }

  // Slider controls
  document.getElementById('stiffness').addEventListener('input', (e) => {
    K = parseFloat(e.target.value);
    document.getElementById('stiffnessValue').textContent = K.toFixed(2);
  });
  
  document.getElementById('damping').addEventListener('input', (e) => {
    DAMP = parseFloat(e.target.value);
    document.getElementById('dampingValue').textContent = DAMP.toFixed(2);
  });
  
  document.getElementById('tangents').addEventListener('input', (e) => {
    tangentLength = parseInt(e.target.value);
    document.getElementById('tangentsValue').textContent = tangentLength;
  });

  // Main animation loop
  let last = performance.now();
  function loop(now) {
    const elapsed = Math.min((now - last) / 1000, 0.05);
    last = now;
    
    stepPhysics(elapsed);
    draw();
    
    requestAnimationFrame(loop);
  }
  
  requestAnimationFrame(loop);

  // For debugging
  window._bezierDemo = { 
    points, 
    physicsData,
    reset: init,
    switchPoint: (index) => {
      monitorPointIndex = index;
      updatePhysicsMonitor();
    }
  };

})();
</script>
</body>
</html>